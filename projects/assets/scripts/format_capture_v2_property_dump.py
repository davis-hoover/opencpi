#!/usr/bin/env python3
# This file is protected by Copyright. Please refer to the COPYRIGHT file
# distributed with this source distribution.
#
# This file is part of OpenCPI <http://www.opencpi.org>
#
# OpenCPI is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.

"""
Use this script to write the dumped final property values of the capture_v2 worker 
to file, in a more readable format (mainly the metadata property). It takes in dump
file generated when running ocpirun or .log file generated by a unit test (e.g. case00.00.capture_v2.hdl.log)
"""

import os.path
import re
import sys
import numpy as np

if len(sys.argv) != 2:
    print("Invalid arguments:  usage is: format_capture_v2_property_dump.py <dumpfile> text file generated when using --dump-file or dumpFile option when running an app")
    sys.exit(1)

def print_border(ofile, rows_width, length):
    for i in range(0, length):
        ofile.write("+" + "-"*rows_width[i])
        if (i == length-1):
            ofile.write("+")
    ofile.write("\n")

def print_row(ofile, row, rows_width, length):
    for i in range(0, length):
        pad = ""
        if(len(row[i]) < rows_width[i]):
            pad = " "*(rows_width[i]-len(row[i]))
        ofile.write("|" + row[i] + pad)
        if (i == length-1):
            ofile.write("|")
    ofile.write("\n")

def print_ascii_table(ofile, row, col_header):
    length = len(row)
    rows_width = np.empty(length, dtype='u4')
    for i in range(0, length):
        rows_width[i] = max(len(row[i]), len(col_header[i])) 

    print_border(ofile,rows_width,length)
    # col_header  
    print_row(ofile, col_header, rows_width, length)
    print_border(ofile, rows_width, length)
    # row
    print_row(ofile, row, rows_width, length)
    print_border(ofile, rows_width, length)


# Do some parsing to grab the final values of the properties
filename = sys.argv[1]
ifile = open(filename, 'r')
lines = ifile.read()
ifile.close()

obj1 = re.findall("capture_v2.stopOnFull = \"(\w+)\"", lines)
obj2 = re.findall("capture_v2.metadataCount = \"(\d+)\".*", lines)
obj3 = re.findall("capture_v2.dataCount = \"(\d+)\".*", lines)
obj4 = re.findall("capture_v2.numRecords = \"(\d+)\".*", lines)
obj5 = re.findall("capture_v2.numDataWords = \"(\d+)\".*", lines)
obj6 = re.findall("capture_v2.metaFull = \"(\w+)\"", lines)
obj7 = re.findall("capture_v2.dataFull = \"(\w+)\"", lines)
obj8 = re.findall("capture_v2.stopZLMOpcode = \"(\d+)\".*", lines)
obj9 = re.findall("capture_v2.stopOnZLM = \"(\w+)\"", lines)
obj10 = re.findall("capture_v2.stopOnEOF = \"(\w+)\"", lines)
obj11 = re.findall("capture_v2.totalBytes = \"(\d+)\".*", lines)
obj12 = re.findall("capture_v2.metadata = \"([^\"]*)\".*", lines)
obj13 = re.findall("capture_v2.data = \"([^\"]*)\".*", lines)
metadataFinal = obj12[1]
dataFinal = obj13[1]

metadata =  [int(x) for x in metadataFinal.replace("{", "").replace("}", "").split(',')]

# u4 is uint32 and setting it to little endian with "<"
dt = np.dtype('<u4')
data = [int(x) for x in dataFinal.split(',')]

stopOnFull = obj1[1]
metadataCount = obj2[1]
dataCount = obj3[1]
numRecords = obj4[0]
numDataWords = obj5[0]
metaFull = obj6[1]
dataFull = obj7[1]
stopZLMOpcode =obj8[1]
stopOnZLM = obj9[1]
stopOnEOF = obj10[1]
totalBytes = obj11[1]

print("Generating an output file that contains capture_v2's properties in a more readable format.")
print("File named capture_v2_props_formatted.txt")


with open("capture_v2_props_formatted.txt", 'w') as f:
    f.write("stopOnFull: " + stopOnFull + "\n")
    f.write("totalBytes: " + totalBytes + "\n")
    f.write("metadataCount: " + metadataCount + "\n")
    f.write("dataCount: " + dataCount + "\n")
    f.write("numRecords: " + numRecords + "\n")
    f.write("numDataWords: " + numDataWords + "\n")
    f.write("metaFull: " + metaFull + "\n")
    f.write("dataFull: " + dataFull + "\n")
    f.write("stopZLMOpcode: " + stopZLMOpcode + "\n")
    f.write("stopOnZLM: " + stopOnZLM + "\n")
    f.write("stopOnEOF: " + stopOnEOF + "\n")
    f.write("\n")
    stop = 4*int(metadataCount)
    if (int(metadataCount) == 0):
        f.write("The metadataCount was 0, so no metadata captured.\n")
        f.write("\n")
    else:   
        for x in range(0, stop, 4):
            som_seconds = metadata[x+3]
            som_fraction = metadata[x+2]
            eom_fraction = metadata[x+1]
            messageSize = (metadata[x] & 0x00FFFFFF)
            opcode = (metadata[x] & 0xFF000000) >> 24
            row = [str(som_seconds), str(som_fraction), str(eom_fraction), str(messageSize), str(opcode)]
            col_header = ["Start of Message Seconds Timestamp", "Start of Message Fraction Timestamp", "End of Message Fraction Timestamp", "Message Size", "Opcode"]
            f.write("Message " + str((x//4)+1) + ":" + "\n")
            print_ascii_table(f, row, col_header)
            f.write("\n")
    if (int(dataCount) == 0):
        f.write("The dataCount was 0, so no data captured.\n")
        f.write("\n")
    else:
        f.write("Data:\n")
        f.write(str(data))
        f.write("\n")