The concept of an assembly (based on XML) is used in a number of places in both tools and runtime C++ code.
The core basic implementation is in the util/assembly directory.  This is runtime code that is also used
for parsing all types of assemblies.

==========RUNTIME ASSEMBLIES
In runtime code, assemblies are used for applications, and there is a stack and inheritance hierarchy
at three levels:

-- The bottom, which is the OCPI::Util::Assembly, which is used for basic XML parsing and whatever
   verification that can be done within the assembly itself, without any higher level constraints or
   knowledge.  This layer also applies and checks runtime PValue parameters to the assembly for the types of
   PValue parameters that can be processes at this low level, with its limited knowledge.  I.e. whatever
   checking that can be done at this level, without higher level artifact or container awareness, *is*
   done at this level.

-- The middle, which is the OCPI::Library::Assembly class, which *inherits* the OCPI::Util::Assembly class.
   This layer adds value because it has knowledge of the runtime artifact libraries, and can thus
   do additional verification with that knowledge, and also develop a list of candidate implementations
   (workers in binary artifacts) for each (application component) instance in the assembly.
   Some PValue parameter processing and error checking can be done at this level, e.g. inserting
   file I/O instances to assembly external ports based on PValue params.  This layer filters artifacts
   by any PValue parameters or XML constraints such as "model", "selection", "platform".

-- The top level, which is the OCPI::API::ApplicationI class, which does not inherit any assembly
   classes, but contains a reference to the OCPI::Library::Assembly that resulted from parsing
   and artifact-library-verification of the application.

==========TOOL/Development Time ASSEMBLIES

THe primary tool-time usage of assemblies is HDL assemblies, which, like application assemblies
are hand-authored by users.  There are also several types of XML assemblies that are generated by tools
and then parsed by the assembly classes.  These include:

-- RCC assemblies when there are potentially multiple workers in one worker binary

-- Platform configuration assemblies that are internally generated after parsing the
   user-authored platform configuration XML files.

-- Container assemnblies that are internally generated after parseing the
   user-authored container XML files.

All these tool-time assemblies are not assemblies of component instances (which is what
application assemblies are), but rather assemblies of (concrete) worker instances, and
the worker instances are specified by the worker *and* the build-configuration of the worker.
The build-configuration of the worker is specified either directly, but actually supplying
a build-configuration ID, or by some property settings that are interpreted as build-time/parameter
settings of the worker instance, and those build-time/parameter settings are used to
identify which of the available build configurations should in fact be instanced.



