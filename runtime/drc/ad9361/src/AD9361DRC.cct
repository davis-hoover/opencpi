/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of OpenCPI <http://www.opencpi.org>
 *
 * OpenCPI is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "AD9361DRC.hh"
#include <iostream>
#include <unistd.h> // usleep()
#include <cinttypes> // PRI...
#include <cmath> // std::round

extern "C" {
#include "ad9361_platform.h"
}

namespace OCPI {

/// @todo / FIXME - consolidate into DRC namespace
namespace DRC_PHASE_2 {

static std::vector<AD9361DeviceCallBack*> g_devices;

// -----------------------------------------------------------------------------
// STEP 1 - DEFINE Constraint Satisfaction Problem (CSP)
// -----------------------------------------------------------------------------

/* @brief for the AD9361,
 *        define variables (X) and their domains (D) for <X,D,C> which
 *        comprises its Constraint Satisfaction Problem (CSP)
 ******************************************************************************/
void
AD9361CSP::define_x_d_ad9361() {
  m_solver.add_var<double>("ad9361_rx_rfpll_lo_freq_meghz", dfp_tol);
  m_solver.add_var<double>("ad9361_tx_rfpll_lo_freq_meghz", dfp_tol);
  m_solver.add_var<double>("ad9361_rx_sampl_freq_meghz", dfp_tol);
  m_solver.add_var<double>("ad9361_tx_sampl_freq_meghz", dfp_tol);
  m_solver.add_var<double>("ad9361_rx_rf_bandwidth_meghz", dfp_tol);
  m_solver.add_var<double>("ad9361_tx_rf_bandwidth_meghz", dfp_tol);
  //m_solver.add_var<int32_t>("ad9361_dac_clk_divider");
  m_solver.add_var<int32_t>("ad9361_dir_rx1");
  m_solver.add_var<int32_t>("ad9361_dir_rx2");
  m_solver.add_var<int32_t>("ad9361_dir_tx1");
  m_solver.add_var<int32_t>("ad9361_dir_tx2");
  m_solver.add_var<double>("ad9361_fc_meghz_rx1", dfp_tol);
  m_solver.add_var<double>("ad9361_fc_meghz_rx2", dfp_tol);
  m_solver.add_var<double>("ad9361_fc_meghz_tx1", dfp_tol);
  m_solver.add_var<double>("ad9361_fc_meghz_tx2", dfp_tol);
  m_solver.add_var<double>("ad9361_bw_meghz_rx1", dfp_tol);
  m_solver.add_var<double>("ad9361_bw_meghz_rx2", dfp_tol);
  m_solver.add_var<double>("ad9361_bw_meghz_tx1", dfp_tol);
  m_solver.add_var<double>("ad9361_bw_meghz_tx2", dfp_tol);
  m_solver.add_var<double>("ad9361_fs_megsps_rx1", dfp_tol);
  m_solver.add_var<double>("ad9361_fs_megsps_rx2", dfp_tol);
  m_solver.add_var<double>("ad9361_fs_megsps_tx1", dfp_tol);
  m_solver.add_var<double>("ad9361_fs_megsps_tx2", dfp_tol);
  m_solver.add_var<int32_t>("ad9361_samps_comp_rx1");
  m_solver.add_var<int32_t>("ad9361_samps_comp_rx2");
  m_solver.add_var<int32_t>("ad9361_samps_comp_tx1");
  m_solver.add_var<int32_t>("ad9361_samps_comp_tx2");
  m_solver.add_var<int32_t>("ad9361_gain_mode_rx1");
  m_solver.add_var<int32_t>("ad9361_gain_mode_rx2");
  m_solver.add_var<int32_t>("ad9361_gain_mode_tx1");
  m_solver.add_var<int32_t>("ad9361_gain_mode_tx2");
  m_solver.add_var<double>("ad9361_gain_db_rx1", dfp_tol);
  m_solver.add_var<double>("ad9361_gain_db_rx2", dfp_tol);
  m_solver.add_var<double>("ad9361_gain_db_tx1", dfp_tol);
  m_solver.add_var<double>("ad9361_gain_db_tx2", dfp_tol);
}

/* @brief for the AD9361,
 *        define constraints (C) for <X,D,C> which
 *        comprise its Constraint Satisfaction Problem (CSP)
 ******************************************************************************/
void
AD9361CSP::define_c_ad9361() {
  m_solver.add_constr("ad9361_rx_rfpll_lo_freq_meghz", ">=", 70.);
  m_solver.add_constr("ad9361_rx_rfpll_lo_freq_meghz", "<=", 6000.);
  m_solver.add_constr("ad9361_tx_rfpll_lo_freq_meghz", ">=", 70.);
  m_solver.add_constr("ad9361_tx_rfpll_lo_freq_meghz", "<=", 6000.);
  /// @TODO replace divider with proper DDC/DUC classes
  m_solver.add_constr("ad9361_rx_rf_bandwidth_meghz", ">=", 0.4/m_divider);
  m_solver.add_constr("ad9361_rx_rf_bandwidth_meghz", "<=", 56./m_divider);
  m_solver.add_constr("ad9361_tx_rf_bandwidth_meghz", ">=", 1.25/m_divider);
  m_solver.add_constr("ad9361_tx_rf_bandwidth_meghz", "<=", 40./m_divider);
  m_solver.add_constr("ad9361_rx_sampl_freq_meghz", ">=", 2.083334/m_divider);
  m_solver.add_constr("ad9361_rx_sampl_freq_meghz", "<=", 61.44/m_divider);
  m_solver.add_constr("ad9361_tx_sampl_freq_meghz", ">=", 2.083334/m_divider);
  m_solver.add_constr("ad9361_tx_sampl_freq_meghz", "<=", 61.44/m_divider);
  //m_solver.add_constr("ad9361_dac_clk_divider", ">=", (int32_t)1);
  //m_solver.add_constr("ad9361_dac_clk_divider", "<=", (int32_t)2);
  m_solver.add_constr("ad9361_dir_rx1", "=", (int32_t)RFPort::direction_t::rx);
  m_solver.add_constr("ad9361_dir_rx2", "=", (int32_t)RFPort::direction_t::rx);
  m_solver.add_constr("ad9361_dir_tx1", "=", (int32_t)RFPort::direction_t::tx);
  m_solver.add_constr("ad9361_dir_tx2", "=", (int32_t)RFPort::direction_t::tx);
  m_solver.add_constr("ad9361_fc_meghz_rx1", "=", "ad9361_rx_rfpll_lo_freq_meghz");
  m_solver.add_constr("ad9361_fc_meghz_rx2", "=", "ad9361_rx_rfpll_lo_freq_meghz");
  m_solver.add_constr("ad9361_fc_meghz_tx1", "=", "ad9361_tx_rfpll_lo_freq_meghz");
  m_solver.add_constr("ad9361_fc_meghz_tx2", "=", "ad9361_tx_rfpll_lo_freq_meghz");
  m_solver.add_constr("ad9361_bw_meghz_rx1", "=", "ad9361_rx_rf_bandwidth_meghz");
  m_solver.add_constr("ad9361_bw_meghz_rx2", "=", "ad9361_rx_rf_bandwidth_meghz");
  m_solver.add_constr("ad9361_bw_meghz_tx1", "=", "ad9361_tx_rf_bandwidth_meghz");
  m_solver.add_constr("ad9361_bw_meghz_tx2", "=", "ad9361_tx_rf_bandwidth_meghz");
  m_solver.add_constr("ad9361_fs_megsps_rx1", "=", "ad9361_rx_sampl_freq_meghz");
  m_solver.add_constr("ad9361_fs_megsps_rx2", "=", "ad9361_rx_sampl_freq_meghz");
  m_solver.add_constr("ad9361_fs_megsps_tx1", "=", "ad9361_tx_sampl_freq_meghz");
  m_solver.add_constr("ad9361_fs_megsps_tx2", "=", "ad9361_tx_sampl_freq_meghz");
  m_solver.add_constr("ad9361_samps_comp_rx1", "=", (int32_t)1);
  m_solver.add_constr("ad9361_samps_comp_rx2", "=", (int32_t)1);
  m_solver.add_constr("ad9361_samps_comp_tx1", "=", (int32_t)1);
  m_solver.add_constr("ad9361_samps_comp_tx2", "=", (int32_t)1);
  m_solver.add_constr("ad9361_gain_mode_rx1", ">=", (int32_t)0); // agc
  m_solver.add_constr("ad9361_gain_mode_rx1", "<=", (int32_t)1); // manual
  m_solver.add_constr("ad9361_gain_mode_rx2", ">=", (int32_t)0); // agc
  m_solver.add_constr("ad9361_gain_mode_rx2", "<=", (int32_t)1); // manual
  m_solver.add_constr("ad9361_gain_mode_tx1", "=", (int32_t)1); // manual
  m_solver.add_constr("ad9361_gain_mode_tx2", "=", (int32_t)1); // manual
  /// @TODO add gain conditional constraints
  m_solver.add_constr("ad9361_gain_db_rx1", ">=", -1.);
  m_solver.add_constr("ad9361_gain_db_rx1", "<=", 62.);
  m_solver.add_constr("ad9361_gain_db_rx2", ">=", -1.);
  m_solver.add_constr("ad9361_gain_db_rx2", "<=", 62.);
  m_solver.add_constr("ad9361_gain_db_tx1", ">=", -89.75);
  m_solver.add_constr("ad9361_gain_db_tx1", "<=", 0.);
  m_solver.add_constr("ad9361_gain_db_tx2", ">=", -89.75);
  m_solver.add_constr("ad9361_gain_db_tx2", "<=", 0.);
}

///@TODO / FIXME handle DDC constants in separate DDC/DUC class
DDCDUCConstants::DDCDUCConstants() :
#ifdef NO_DDC_DUC
    m_divider(1)
#else
    m_divider(16)
#endif
    {
}

///@TODO / FIXME handle constants in separate DDC/DUC class
AD9361CSP::AD9361CSP() : CSPBase(), DDCDUCConstants() {
  define();
  //std::cout << "[INFO] " << get_feasible_region_limits() << "\n";
}

/* @brief instance AD9361
 *        by defining its Constraint Satisfaction Problem (CSP) as <X,D,C>
 ******************************************************************************/
void
AD9361CSP::instance_ad9361() {
  define_x_d_ad9361();
  define_c_ad9361();
}

/// @brief define Constraint Satisfaction Problem (CSP)
void
AD9361CSP::define() {
  instance_ad9361();
}

// -----------------------------------------------------------------------------
// STEP 2 - DEFINE CONFIGURATOR THAT UTILIZES THE CSP
// -----------------------------------------------------------------------------

AD9361Configurator::AD9361Configurator() : Configurator<AD9361CSP>() {
  init_rf_port_rx1();
  init_rf_port_rx2();
  init_rf_port_tx1();
  init_rf_port_tx2();
}

void
AD9361Configurator::init_rf_port_rx1() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names which are specific to this DRC (a CSP is generic and knows
  // nothing about a DRC, this is what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "ad9361_dir_rx1"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "ad9361_fc_meghz_rx1"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "ad9361_bw_meghz_rx1"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "ad9361_fs_megsps_rx1"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "ad9361_samps_comp_rx1"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "ad9361_gain_mode_rx1"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "ad9361_gain_db_rx1"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  m_dict["rx1"] = map;
}

void
AD9361Configurator::init_rf_port_rx2() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names which are specific to this DRC (a CSP is generic and knows
  // nothing about a DRC, this is what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "ad9361_dir_rx2"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "ad9361_fc_meghz_rx2"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "ad9361_bw_meghz_rx2"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "ad9361_fs_megsps_rx2"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "ad9361_samps_comp_rx2"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "ad9361_gain_mode_rx2"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "ad9361_gain_db_rx2"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  m_dict["rx2"] = map;
}

void
AD9361Configurator::init_rf_port_tx1() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names which are specific to this DRC (a CSP is generic and knows
  // nothing about a DRC, this is what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "ad9361_dir_tx1"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "ad9361_fc_meghz_tx1"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "ad9361_bw_meghz_tx1"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "ad9361_fs_megsps_tx1"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "ad9361_samps_comp_tx1"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "ad9361_gain_mode_tx1"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "ad9361_gain_db_tx1"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  m_dict["tx1"] = map;
}

void
AD9361Configurator::init_rf_port_tx2() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names which are specific to this DRC (a CSP is generic and knows
  // nothing about a DRC, this is what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "ad9361_dir_tx2"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "ad9361_fc_meghz_tx2"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "ad9361_bw_meghz_tx2"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "ad9361_fs_megsps_tx2"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "ad9361_samps_comp_tx2"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "ad9361_gain_mode_tx2"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "ad9361_gain_db_tx2"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  m_dict["tx2"] = map;
}

template<class cfgrtr_t>
template<typename T> T
AD9361DRC<cfgrtr_t>::convert_milli_db_to_db(T val_milli_db) const {
  return val_milli_db/1000;
}

template<class cfgrtr_t>
template<typename T> T
AD9361DRC<cfgrtr_t>::convert_db_to_milli_db(T val_milli_db) const {
  return val_milli_db*1000;
}

#ifndef DISABLE_AD9361
///@brief get No-OS-specific "channel" macro (RX1/RX2/TX1/TX2 in ad9361_api.h)
template<class cfgrtr_t> uint8_t
AD9361DRC<cfgrtr_t>::get_ch(std::string port) {
  uint8_t res = 
      (port == m_port_rx1) ? RX1 :
      (port == m_port_rx2) ? (m_ad9361_rf_phy->pdata->rx2tx2 ? RX2 : RX1) :
      (port == m_port_tx1) ? TX1 :
      (port == m_port_tx2) ? (m_ad9361_rf_phy->pdata->rx2tx2 ? TX2 : TX1) : RX1;
  return res;
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::init_init_param() {
  AD9361_InitParam init_param = {
    /* Device selection */
    ID_AD9361,	// dev_sel
    /* Identification number */
    0,		//id_no
    /* Reference Clock */
    40000000UL,	//reference_clk_rate
    /* Base Configuration */
    1,		//two_rx_two_tx_mode_enable *** adi,2rx-2tx-mode-enable
    1,		//one_rx_one_tx_mode_use_rx_num *** adi,1rx-1tx-mode-use-rx-num
    1,		//one_rx_one_tx_mode_use_tx_num *** adi,1rx-1tx-mode-use-tx-num
    1,		//frequency_division_duplex_mode_enable *** adi,frequency-division-duplex-mode-enable

    // frequency_division_duplex_independent_mode_enable=1 required for
    // ad9361_dac.hdl event port to operate as intended
    1,		//frequency_division_duplex_independent_mode_enable *** adi,frequency-division-duplex-independent-mode-enable

    0,		//tdd_use_dual_synth_mode_enable *** adi,tdd-use-dual-synth-mode-enable
    0,		//tdd_skip_vco_cal_enable *** adi,tdd-skip-vco-cal-enable
    0,		//tx_fastlock_delay_ns *** adi,tx-fastlock-delay-ns
    0,		//rx_fastlock_delay_ns *** adi,rx-fastlock-delay-ns
    0,		//rx_fastlock_pincontrol_enable *** adi,rx-fastlock-pincontrol-enable
    0,		//tx_fastlock_pincontrol_enable *** adi,tx-fastlock-pincontrol-enable
    0,		//external_rx_lo_enable *** adi,external-rx-lo-enable
    0,		//external_tx_lo_enable *** adi,external-tx-lo-enable
    5,		//dc_offset_tracking_update_event_mask *** adi,dc-offset-tracking-update-event-mask
    6,		//dc_offset_attenuation_high_range *** adi,dc-offset-attenuation-high-range
    5,		//dc_offset_attenuation_low_range *** adi,dc-offset-attenuation-low-range
    0x28,	//dc_offset_count_high_range *** adi,dc-offset-count-high-range
    0x32,	//dc_offset_count_low_range *** adi,dc-offset-count-low-range
    0,		//split_gain_table_mode_enable *** adi,split-gain-table-mode-enable
    MAX_SYNTH_FREF,	//trx_synthesizer_target_fref_overwrite_hz *** adi,trx-synthesizer-target-fref-overwrite-hz
    0,		// qec_tracking_slow_mode_enable *** adi,qec-tracking-slow-mode-enable
    /* ENSM Control */
    0,		//ensm_enable_pin_pulse_mode_enable *** adi,ensm-enable-pin-pulse-mode-enable
    0,		//ensm_enable_txnrx_control_enable *** adi,ensm-enable-txnrx-control-enable
    /* LO Control */
    2400000000UL,	//rx_synthesizer_frequency_hz *** adi,rx-synthesizer-frequency-hz
    2400000000UL,	//tx_synthesizer_frequency_hz *** adi,tx-synthesizer-frequency-hz
    1,        //tx_lo_powerdown_managed_enable *** adi,tx-lo-powerdown-managed-enable
    /* Rate & BW Control */
    {983040000, 245760000, 122880000, 61440000, 30720000, 30720000},// rx_path_clock_frequencies[6] *** adi,rx-path-clock-frequencies
    {983040000, 122880000, 122880000, 61440000, 30720000, 30720000},// tx_path_clock_frequencies[6] *** adi,tx-path-clock-frequencies
    18000000,//rf_rx_bandwidth_hz *** adi,rf-rx-bandwidth-hz
    18000000,//rf_tx_bandwidth_hz *** adi,rf-tx-bandwidth-hz
    /* RF Port Control */
    0,		//rx_rf_port_input_select *** adi,rx-rf-port-input-select
    0,		//tx_rf_port_input_select *** adi,tx-rf-port-input-select
    /* TX Attenuation Control */
    10000,	//tx_attenuation_mdB *** adi,tx-attenuation-mdB
    0,		//update_tx_gain_in_alert_enable *** adi,update-tx-gain-in-alert-enable
    /* Reference Clock Control */
    0,		//xo_disable_use_ext_refclk_enable *** adi,xo-disable-use-ext-refclk-enable
    {8, 5920},	//dcxo_coarse_and_fine_tune[2] *** adi,dcxo-coarse-and-fine-tune
    CLKOUT_DISABLE,	//clk_output_mode_select *** adi,clk-output-mode-select
    /* Gain Control */
    2,		//gc_rx1_mode *** adi,gc-rx1-mode
    2,		//gc_rx2_mode *** adi,gc-rx2-mode
    58,		//gc_adc_large_overload_thresh *** adi,gc-adc-large-overload-thresh
    4,		//gc_adc_ovr_sample_size *** adi,gc-adc-ovr-sample-size
    47,		//gc_adc_small_overload_thresh *** adi,gc-adc-small-overload-thresh
    8192,	//gc_dec_pow_measurement_duration *** adi,gc-dec-pow-measurement-duration
    0,		//gc_dig_gain_enable *** adi,gc-dig-gain-enable
    800,	//gc_lmt_overload_high_thresh *** adi,gc-lmt-overload-high-thresh
    704,	//gc_lmt_overload_low_thresh *** adi,gc-lmt-overload-low-thresh
    24,		//gc_low_power_thresh *** adi,gc-low-power-thresh
    15,		//gc_max_dig_gain *** adi,gc-max-dig-gain
    /* Gain MGC Control */
    2,		//mgc_dec_gain_step *** adi,mgc-dec-gain-step
    2,		//mgc_inc_gain_step *** adi,mgc-inc-gain-step
    0,		//mgc_rx1_ctrl_inp_enable *** adi,mgc-rx1-ctrl-inp-enable
    0,		//mgc_rx2_ctrl_inp_enable *** adi,mgc-rx2-ctrl-inp-enable
    0,		//mgc_split_table_ctrl_inp_gain_mode *** adi,mgc-split-table-ctrl-inp-gain-mode
    /* Gain AGC Control */
    10,		//agc_adc_large_overload_exceed_counter *** adi,agc-adc-large-overload-exceed-counter
    2,		//agc_adc_large_overload_inc_steps *** adi,agc-adc-large-overload-inc-steps
    0,		//agc_adc_lmt_small_overload_prevent_gain_inc_enable *** adi,agc-adc-lmt-small-overload-prevent-gain-inc-enable
    10,		//agc_adc_small_overload_exceed_counter *** adi,agc-adc-small-overload-exceed-counter
    4,		//agc_dig_gain_step_size *** adi,agc-dig-gain-step-size
    3,		//agc_dig_saturation_exceed_counter *** adi,agc-dig-saturation-exceed-counter
    1000,	// agc_gain_update_interval_us *** adi,agc-gain-update-interval-us
    0,		//agc_immed_gain_change_if_large_adc_overload_enable *** adi,agc-immed-gain-change-if-large-adc-overload-enable
    0,		//agc_immed_gain_change_if_large_lmt_overload_enable *** adi,agc-immed-gain-change-if-large-lmt-overload-enable
    10,		//agc_inner_thresh_high *** adi,agc-inner-thresh-high
    1,		//agc_inner_thresh_high_dec_steps *** adi,agc-inner-thresh-high-dec-steps
    12,		//agc_inner_thresh_low *** adi,agc-inner-thresh-low
    1,		//agc_inner_thresh_low_inc_steps *** adi,agc-inner-thresh-low-inc-steps
    10,		//agc_lmt_overload_large_exceed_counter *** adi,agc-lmt-overload-large-exceed-counter
    2,		//agc_lmt_overload_large_inc_steps *** adi,agc-lmt-overload-large-inc-steps
    10,		//agc_lmt_overload_small_exceed_counter *** adi,agc-lmt-overload-small-exceed-counter
    5,		//agc_outer_thresh_high *** adi,agc-outer-thresh-high
    2,		//agc_outer_thresh_high_dec_steps *** adi,agc-outer-thresh-high-dec-steps
    18,		//agc_outer_thresh_low *** adi,agc-outer-thresh-low
    2,		//agc_outer_thresh_low_inc_steps *** adi,agc-outer-thresh-low-inc-steps
    1,		//agc_attack_delay_extra_margin_us; *** adi,agc-attack-delay-extra-margin-us
    0,		//agc_sync_for_gain_counter_enable *** adi,agc-sync-for-gain-counter-enable
    /* Fast AGC */
    64,		//fagc_dec_pow_measuremnt_duration ***  adi,fagc-dec-pow-measurement-duration
    260,	//fagc_state_wait_time_ns ***  adi,fagc-state-wait-time-ns
    /* Fast AGC - Low Power */
    0,		//fagc_allow_agc_gain_increase ***  adi,fagc-allow-agc-gain-increase-enable
    5,		//fagc_lp_thresh_increment_time ***  adi,fagc-lp-thresh-increment-time
    1,		//fagc_lp_thresh_increment_steps ***  adi,fagc-lp-thresh-increment-steps
    /* Fast AGC - Lock Level (Lock Level is set via slow AGC inner high threshold) */
    1,		//fagc_lock_level_lmt_gain_increase_en ***  adi,fagc-lock-level-lmt-gain-increase-enable
    5,		//fagc_lock_level_gain_increase_upper_limit ***  adi,fagc-lock-level-gain-increase-upper-limit
    /* Fast AGC - Peak Detectors and Final Settling */
    1,		//fagc_lpf_final_settling_steps ***  adi,fagc-lpf-final-settling-steps
    1,		//fagc_lmt_final_settling_steps ***  adi,fagc-lmt-final-settling-steps
    3,		//fagc_final_overrange_count ***  adi,fagc-final-overrange-count
    /* Fast AGC - Final Power Test */
    0,		//fagc_gain_increase_after_gain_lock_en ***  adi,fagc-gain-increase-after-gain-lock-enable
    /* Fast AGC - Unlocking the Gain */
    0,		//fagc_gain_index_type_after_exit_rx_mode ***  adi,fagc-gain-index-type-after-exit-rx-mode
    1,		//fagc_use_last_lock_level_for_set_gain_en ***  adi,fagc-use-last-lock-level-for-set-gain-enable
    1,		//fagc_rst_gla_stronger_sig_thresh_exceeded_en ***  adi,fagc-rst-gla-stronger-sig-thresh-exceeded-enable
    5,		//fagc_optimized_gain_offset ***  adi,fagc-optimized-gain-offset
    10,		//fagc_rst_gla_stronger_sig_thresh_above_ll ***  adi,fagc-rst-gla-stronger-sig-thresh-above-ll
    1,		//fagc_rst_gla_engergy_lost_sig_thresh_exceeded_en ***  adi,fagc-rst-gla-engergy-lost-sig-thresh-exceeded-enable
    1,		//fagc_rst_gla_engergy_lost_goto_optim_gain_en ***  adi,fagc-rst-gla-engergy-lost-goto-optim-gain-enable
    10,		//fagc_rst_gla_engergy_lost_sig_thresh_below_ll ***  adi,fagc-rst-gla-engergy-lost-sig-thresh-below-ll
    8,		//fagc_energy_lost_stronger_sig_gain_lock_exit_cnt ***  adi,fagc-energy-lost-stronger-sig-gain-lock-exit-cnt
    1,		//fagc_rst_gla_large_adc_overload_en ***  adi,fagc-rst-gla-large-adc-overload-enable
    1,		//fagc_rst_gla_large_lmt_overload_en ***  adi,fagc-rst-gla-large-lmt-overload-enable
    0,		//fagc_rst_gla_en_agc_pulled_high_en ***  adi,fagc-rst-gla-en-agc-pulled-high-enable
    0,		//fagc_rst_gla_if_en_agc_pulled_high_mode ***  adi,fagc-rst-gla-if-en-agc-pulled-high-mode
    64,		//fagc_power_measurement_duration_in_state5 ***  adi,fagc-power-measurement-duration-in-state5
    /* RSSI Control */
    1,		//rssi_delay *** adi,rssi-delay
    1000,	//rssi_duration *** adi,rssi-duration
    3,		//rssi_restart_mode *** adi,rssi-restart-mode
    0,		//rssi_unit_is_rx_samples_enable *** adi,rssi-unit-is-rx-samples-enable
    1,		//rssi_wait *** adi,rssi-wait
    /* Aux ADC Control */
    256,	//aux_adc_decimation *** adi,aux-adc-decimation
    40000000UL,	//aux_adc_rate *** adi,aux-adc-rate
    /* AuxDAC Control */
    1,		//aux_dac_manual_mode_enable ***  adi,aux-dac-manual-mode-enable
    0,		//aux_dac1_default_value_mV ***  adi,aux-dac1-default-value-mV
    0,		//aux_dac1_active_in_rx_enable ***  adi,aux-dac1-active-in-rx-enable
    0,		//aux_dac1_active_in_tx_enable ***  adi,aux-dac1-active-in-tx-enable
    0,		//aux_dac1_active_in_alert_enable ***  adi,aux-dac1-active-in-alert-enable
    0,		//aux_dac1_rx_delay_us ***  adi,aux-dac1-rx-delay-us
    0,		//aux_dac1_tx_delay_us ***  adi,aux-dac1-tx-delay-us
    0,		//aux_dac2_default_value_mV ***  adi,aux-dac2-default-value-mV
    0,		//aux_dac2_active_in_rx_enable ***  adi,aux-dac2-active-in-rx-enable
    0,		//aux_dac2_active_in_tx_enable ***  adi,aux-dac2-active-in-tx-enable
    0,		//aux_dac2_active_in_alert_enable ***  adi,aux-dac2-active-in-alert-enable
    0,		//aux_dac2_rx_delay_us ***  adi,aux-dac2-rx-delay-us
    0,		//aux_dac2_tx_delay_us ***  adi,aux-dac2-tx-delay-us
    /* Temperature Sensor Control */
    256,	//temp_sense_decimation *** adi,temp-sense-decimation
    1000,	//temp_sense_measurement_interval_ms *** adi,temp-sense-measurement-interval-ms
    (int8_t)0xCE,	//temp_sense_offset_signed *** adi,temp-sense-offset-signed //0xCE,	//temp_sense_offset_signed *** adi,temp-sense-offset-signed
    1,		//temp_sense_periodic_measurement_enable *** adi,temp-sense-periodic-measurement-enable
    /* Control Out Setup */
    0xFF,	//ctrl_outs_enable_mask *** adi,ctrl-outs-enable-mask
    0,		//ctrl_outs_index *** adi,ctrl-outs-index
    /* External LNA Control */
    0,		//elna_settling_delay_ns *** adi,elna-settling-delay-ns
    0,		//elna_gain_mdB *** adi,elna-gain-mdB
    0,		//elna_bypass_loss_mdB *** adi,elna-bypass-loss-mdB
    0,		//elna_rx1_gpo0_control_enable *** adi,elna-rx1-gpo0-control-enable
    0,		//elna_rx2_gpo1_control_enable *** adi,elna-rx2-gpo1-control-enable
    0,		//elna_gaintable_all_index_enable *** adi,elna-gaintable-all-index-enable
    /* Digital Interface Control */
    0,		//digital_interface_tune_skip_mode *** adi,digital-interface-tune-skip-mode
    0,		//digital_interface_tune_fir_disable *** adi,digital-interface-tune-fir-disable
    1,		//pp_tx_swap_enable *** adi,pp-tx-swap-enable
    1,		//pp_rx_swap_enable *** adi,pp-rx-swap-enable
    0,		//tx_channel_swap_enable *** adi,tx-channel-swap-enable
    0,		//rx_channel_swap_enable *** adi,rx-channel-swap-enable
    1,		//rx_frame_pulse_mode_enable *** adi,rx-frame-pulse-mode-enable
    0,		//two_t_two_r_timing_enable *** adi,2t2r-timing-enable
    0,		//invert_data_bus_enable *** adi,invert-data-bus-enable
    0,		//invert_data_clk_enable *** adi,invert-data-clk-enable
    0,		//fdd_alt_word_order_enable *** adi,fdd-alt-word-order-enable
    0,		//invert_rx_frame_enable *** adi,invert-rx-frame-enable
    0,		//fdd_rx_rate_2tx_enable *** adi,fdd-rx-rate-2tx-enable
    0,		//swap_ports_enable *** adi,swap-ports-enable
    0,		//single_data_rate_enable *** adi,single-data-rate-enable
    1,		//lvds_mode_enable *** adi,lvds-mode-enable
    0,		//half_duplex_mode_enable *** adi,half-duplex-mode-enable
    0,		//single_port_mode_enable *** adi,single-port-mode-enable
    0,		//full_port_enable *** adi,full-port-enable
    0,		//full_duplex_swap_bits_enable *** adi,full-duplex-swap-bits-enable
    0,		//delay_rx_data *** adi,delay-rx-data
    0,		//rx_data_clock_delay *** adi,rx-data-clock-delay
    4,		//rx_data_delay *** adi,rx-data-delay
    7,		//tx_fb_clock_delay *** adi,tx-fb-clock-delay
    0,		//tx_data_delay *** adi,tx-data-delay
  #ifdef ALTERA_PLATFORM
    300,	//lvds_bias_mV *** adi,lvds-bias-mV
  #else
    150,	//lvds_bias_mV *** adi,lvds-bias-mV
  #endif
    1,		//lvds_rx_onchip_termination_enable *** adi,lvds-rx-onchip-termination-enable
    0,		//rx1rx2_phase_inversion_en *** adi,rx1-rx2-phase-inversion-enable
    0xFF,	//lvds_invert1_control *** adi,lvds-invert1-control
    0x0F,	//lvds_invert2_control *** adi,lvds-invert2-control
    /* GPO Control */
    0,		//gpo0_inactive_state_high_enable *** adi,gpo0-inactive-state-high-enable
    0,		//gpo1_inactive_state_high_enable *** adi,gpo1-inactive-state-high-enable
    0,		//gpo2_inactive_state_high_enable *** adi,gpo2-inactive-state-high-enable
    0,		//gpo3_inactive_state_high_enable *** adi,gpo3-inactive-state-high-enable
    0,		//gpo0_slave_rx_enable *** adi,gpo0-slave-rx-enable
    0,		//gpo0_slave_tx_enable *** adi,gpo0-slave-tx-enable
    0,		//gpo1_slave_rx_enable *** adi,gpo1-slave-rx-enable
    0,		//gpo1_slave_tx_enable *** adi,gpo1-slave-tx-enable
    0,		//gpo2_slave_rx_enable *** adi,gpo2-slave-rx-enable
    0,		//gpo2_slave_tx_enable *** adi,gpo2-slave-tx-enable
    0,		//gpo3_slave_rx_enable *** adi,gpo3-slave-rx-enable
    0,		//gpo3_slave_tx_enable *** adi,gpo3-slave-tx-enable
    0,		//gpo0_rx_delay_us *** adi,gpo0-rx-delay-us
    0,		//gpo0_tx_delay_us *** adi,gpo0-tx-delay-us
    0,		//gpo1_rx_delay_us *** adi,gpo1-rx-delay-us
    0,		//gpo1_tx_delay_us *** adi,gpo1-tx-delay-us
    0,		//gpo2_rx_delay_us *** adi,gpo2-rx-delay-us
    0,		//gpo2_tx_delay_us *** adi,gpo2-tx-delay-us
    0,		//gpo3_rx_delay_us *** adi,gpo3-rx-delay-us
    0,		//gpo3_tx_delay_us *** adi,gpo3-tx-delay-us
    /* Tx Monitor Control */
    37000,	//low_high_gain_threshold_mdB *** adi,txmon-low-high-thresh
    0,		//low_gain_dB *** adi,txmon-low-gain
    24,		//high_gain_dB *** adi,txmon-high-gain
    0,		//tx_mon_track_en *** adi,txmon-dc-tracking-enable
    0,		//one_shot_mode_en *** adi,txmon-one-shot-mode-enable
    511,	//tx_mon_delay *** adi,txmon-delay
    8192,	//tx_mon_duration *** adi,txmon-duration
    2,		//tx1_mon_front_end_gain *** adi,txmon-1-front-end-gain
    2,		//tx2_mon_front_end_gain *** adi,txmon-2-front-end-gain
    48,		//tx1_mon_lo_cm *** adi,txmon-1-lo-cm
    48,		//tx2_mon_lo_cm *** adi,txmon-2-lo-cm
    /* GPIO definitions */
    -1,		//gpio_resetb *** reset-gpios
    /* MCS Sync */
    -1,		//gpio_sync *** sync-gpios
    -1,		//gpio_cal_sw1 *** cal-sw1-gpios
    -1,		//gpio_cal_sw2 *** cal-sw2-gpios
    /* External LO clocks */
    NULL,	//(*ad9361_rfpll_ext_recalc_rate)()
    NULL,	//(*ad9361_rfpll_ext_round_rate)()
    NULL	//(*ad9361_rfpll_ext_set_rate)()
  };
  m_init_param = init_param;
  m_init_param.id_no = m_device;
  // assign m_AD9361_InitParam.gpio_resetb to the arbitrarily defined GPIO_RESET_PIN so
  // that the No-OS opencpi platform driver knows to drive the force_reset
  // property of the sub-device
  m_init_param.gpio_resetb = (m_device << 8) | GPIO_RESET_PIN;
  g_devices.resize(m_device+1);
  g_devices[m_device] = &m_callback;
}

// C interface for NoOs Library callbacks to touch the actual device (config slave)
static void get_byte(uint8_t id_no, uint16_t addr, uint8_t *buf) {
  g_devices[id_no]->get_byte(id_no, addr, buf);
}

static void set_byte(uint8_t id_no, uint16_t addr, const uint8_t *buf) {
  g_devices[id_no]->set_byte(id_no, addr, buf);
}

static void set_reset(uint8_t id_no, bool on) {
  g_devices[id_no]->set_reset(id_no, on);
}

template<class cfgrtr_t> bool
AD9361DRC<cfgrtr_t>::request_config_lock(uint16_t id,
    const ConfigLockRequest& request) {
  static bool first = true;
  if(first) {
    init();
    first = false;
  }
  uint32_t mode;
  ad9361_get_en_state_machine_mode(m_ad9361_rf_phy, &mode);
  this->log_info("drc: mode = %" PRIu32, mode);
  return DRC<cfgrtr_t>::request_config_lock(id,request);
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::init() {
  // only initialize if there are no existing locks which conflict
  if(any_configurator_configs_locked_which_prevent_ad9361_init()) {
    throw std::string("reinit required but configs locked which prevent");
  }
  if(not m_ad9361_init_called) { // spi_init() only needs to happen once
    // nasty cast below included since compiler wouldn't let us cast from
    // ...WorkerTypes::...WorkerBase::Slave to
    // OCPI::RCC_RCCUserSlave since the former inherits privately from the
    // latter inside the RCC worker's generated header
    //spi_init(static_cast<OCPI::RCC::RCCUserSlave*>(static_cast<void *>(&m_cfg_slave)));
    ad9361_opencpi.get_byte = get_byte;
    ad9361_opencpi.set_byte = set_byte;
    ad9361_opencpi.set_reset = set_reset;
    ad9361_opencpi.worker = this->m_descriptor.c_str();
  }
  /*
    three phases of callback:
    1. Before init
    2. After init success or failure
    3. After init success
  */

  // This is our config structure which is then translated into the no-OS library's own init structure
  Ad9361InitConfig cfg;
  // Call back to the proxy to fill in or modify this structure further, before acting on it.
  m_callback.initialConfig(m_device, cfg);
  // Translate from our config structure to the no-OS library's config structure
  apply_config_to_init_param(cfg);
  // assign m_AD9361_InitParam.gpio_resetb to the arbitrarily defined GPIO_RESET_PIN so
  // that the No-OS opencpi platform driver knows to drive the force_reset
  // property of the sub-device
  //m_init_param.gpio_resetb = GPIO_RESET_PIN;
  //m_init_param.reference_clk_rate = (uint32_t) std::round(m_fref_hz);
  // here is where we enforce the ad9361_config OWD comment
  // "[the force_two_r_two_t_timing] property is expected to correspond to the
  // D2 bit of the Parallel Port Configuration 1 register at SPI address 0x010
  //m_cfg_slave.set_force_two_r_two_t_timing(m_init_param.two_t_two_r_timing_enable);
  // ADI forum post recommended setting ENABLE/TXNRX pins high *prior to
  // ad9361_init() call* when
  // frequency_division_duplex_independent_mode_enable is set to 1
  //m_cfg_slave.set_ENABLE_force_set(true);
  //m_cfg_slave.set_TXNRX_force_set(true);
  // sleep duration chosen to be relatively small in relation to AD9361
  // initialization duration (which, through observation, appears to be
  // roughly 200 ms), but a long enough pulse that AD9361 is likely
  // recognizing it many, many times over
  usleep(1000);
  // the below method call allocates memory for ad9361, the address of which is
  // pointed to by m_ad9361_rf_phy once the method returns
  this->log_info("noos ad9361_init");
  m_ad9361_init_ret = ad9361_init(&m_ad9361_rf_phy,&m_init_param);
  ad9361_set_tx_fir_en_dis(m_ad9361_rf_phy, 0); // disable tx_fir with the ad9361_api library in all cases
  m_callback.postConfig(m_device);
  m_ad9361_init_called = true;
  if(m_ad9361_init_ret == -ENODEV) {
    throw std::string("AD9361 init failed: SPI could not be established");
  }
  else if(m_ad9361_init_ret != 0) {
    throw std::string("AD9361 init failed");
  }
  if(m_ad9361_rf_phy == 0) {
    throw std::string("AD9361 init failed");
  }
  //because channel config potentially changed
  //set_ad9361_fpga_channel_config();
  // Successful Initialization, tell workers about what happened.
  m_callback.finalConfig(m_device, cfg);
}

template<class cfgrtr_t> bool
AD9361DRC<cfgrtr_t>::any_configurator_configs_locked_which_prevent_ad9361_init() const {
  typedef RFPort::config_t cfg_t;
  std::vector<std::string> rf_port_names;
  rf_port_names.push_back((m_port_rx1));
  rf_port_names.push_back((m_port_rx2));
  rf_port_names.push_back((m_port_tx1));
  rf_port_names.push_back((m_port_tx2));
  const auto& configurator = this->m_configurator;
  for (auto it = rf_port_names.begin(); it != rf_port_names.end(); ++it) {
    std::vector<std::string> var_names;
    // direction and samples_are_complex are ignored because they are static
    // on the AD9361
    var_names.push_back(configurator.m_dict.at(*it).at(cfg_t::tuning_freq_MHz));
    var_names.push_back(configurator.m_dict.at(*it).at(cfg_t::bandwidth_3dB_MHz));
    var_names.push_back(configurator.m_dict.at(*it).at(cfg_t::sampling_rate_Msps));
    var_names.push_back(configurator.m_dict.at(*it).at(cfg_t::gain_mode));
    var_names.push_back(configurator.m_dict.at(*it).at(cfg_t::gain_dB));
    for (auto itv = var_names.begin(); itv != var_names.end(); ++itv)
      if (configurator.get_csp_var_is_locked(*itv))
        return true;
  }
  return false;
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::throw_if_ad9361_init_failed(
    const char* operation) const {
  if(m_ad9361_init_ret != 0) {
    std::ostringstream oss;
    oss << "cannot perform ";
    oss << (operation ? operation : "operation");
    oss << " because ad9361_init() failed";
    throw oss.str();
  }
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::apply_config_to_init_param(const Ad9361InitConfig &config) {
  m_init_param.xo_disable_use_ext_refclk_enable = config.xo_disable_use_ext_ref_clk;
  m_fref_hz = config.ext_ref_clk_freq;
  m_init_param.reference_clk_rate = (uint32_t) round(m_fref_hz);
  bool is_2r1t_or_1r2t_or_2r2t =
      config.qadc1_is_present or config.qdac1_is_present;
  ///@TODO investigate Platform_ad9361_configWorkerTypes::DATA_RATE_CONFIG_SDR;
  m_init_param.rx_frame_pulse_mode_enable =
      config.rx_frame_toggle ? 1 : 0;
  m_init_param.invert_data_bus_enable =
      config.data_bus_index_reverse ? 1 : 0;
  m_init_param.invert_data_clk_enable =
      config.data_clk_is_inverted ? 1 : 0;
  m_init_param.invert_rx_frame_enable =
      config.rx_frame_is_inverted ? 1 : 0;
  if(config.LVDS)
  {
    m_init_param.lvds_rx_onchip_termination_enable = 1;
    m_init_param.lvds_mode_enable                  = 1;
    // AD9361_Reference_Manual_UG-570.pdf (Rev. A):
    // "The following bits are not supported in LVDS mode:
    // * Swap Ports-In LVDS mode, P0 is Tx and P1 is Rx. This configuration cannot be changed.
    // * Single Port Mode-Both ports are enabled in LVDS mode.
    // * FDD Full Port-Not supported in LVDS.
    // * FDD Alt Word Order-Not supported in LVDS.
    // * FDD Swap Bits-Not supported in LVDS."
    m_init_param.swap_ports_enable            = 0;
    m_init_param.single_port_mode_enable      = 0;
    m_init_param.full_port_enable             = 0;
    m_init_param.fdd_alt_word_order_enable    = 0; ///@TODO/FIXME read this value from FPGA?
    m_init_param.half_duplex_mode_enable      = 0;
    m_init_param.single_data_rate_enable      = 0;
    m_init_param.full_duplex_swap_bits_enable = 0; ///@TODO / FIXME read this value from FPGA?
  }
  else { // mode is CMOS
    m_init_param.lvds_rx_onchip_termination_enable = 0;
    m_init_param.lvds_mode_enable                  = 0;
    m_init_param.swap_ports_enable         =
        config.swap_ports ? 1 : 0;
    m_init_param.single_port_mode_enable   =
        config.single_port ? 1 : 0;
    m_init_param.fdd_alt_word_order_enable = 0; ///@TODO/FIXME read this value from FPGA?
    m_init_param.full_port_enable          = (!config.half_duplex) and (!config.single_port);
    m_init_param.half_duplex_mode_enable   = config.half_duplex ? 1 : 0;
    m_init_param.single_data_rate_enable   =
        config.data_rate_ddr ? 0 : 1;
    m_init_param.full_duplex_swap_bits_enable = 0; ///@TODO / FIXME read this value from FPGA?
  }
  m_init_param.two_rx_two_tx_mode_enable = is_2r1t_or_1r2t_or_2r2t ? 1 : 0;
  m_init_param.rx_data_clock_delay = config.DATA_CLK_Delay;
  m_init_param.rx_data_delay       = config.RX_Data_Delay;
  m_init_param.tx_fb_clock_delay   = config.FB_CLK_Delay;
  m_init_param.tx_data_delay       = config.TX_Data_Delay;
}

#endif // DISABLE_AD9361

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::init_if_required() {
#ifndef DISABLE_AD9361
  if(not m_ad9361_init_called) {
    init();
  }
#endif
}

template<class cfgrtr_t>
AD9361DRC<cfgrtr_t>::AD9361DRC(unsigned which,
		AD9361DeviceCallBack &dev, double fref_hz,
    const char* rx1, const char* rx2, const char* tx1, const char* tx2,
    const char* descriptor) :
    DRC<cfgrtr_t>(descriptor), DDCDUCConstants(),
#ifndef DISABLE_AD9361
    m_fref_hz(fref_hz),
    m_ad9361_rf_phy(_ad9361_phy),
    m_ad9361_init_ret(-1),
    m_ad9361_init_called(false),
#endif
    m_port_rx1(rx1), m_port_rx2(rx2), m_port_tx1(tx1), m_port_tx2(tx2),
    m_callback(dev),
    m_device(which) {
  //std::ostringstream oss;
  //oss << "constructor ";
  //oss << this->m_configurator.get_feasible_region_limits() << "\n";
  //std::cout << oss.str() << "\n";
  //this->log_info(oss.str().c_str());
#ifndef DISABLE_AD9361
  init_init_param();
#endif
}

template<class cfgrtr_t> bool
AD9361DRC<cfgrtr_t>::get_rx_and_throw_if_invalid_rf_port_name(
    std::string rf_port_name) const {
  bool do_rx = false;
  if(rf_port_name == m_port_rx1) {
    do_rx = true;
  }
  else if(rf_port_name == m_port_rx2) {
    do_rx = true;
  }
  else if(rf_port_name == m_port_tx1) {
    do_rx = false;
  }
  else if(rf_port_name == m_port_tx2) {
    do_rx = false;
  }
  else {
    this->throw_invalid_rf_port_name(rf_port_name);
  }
  return do_rx;
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_rx_rf_port_input(uint32_t mode) {
  init_if_required();
  this->log_info("noos ad9361_set_rx_rf_port_input %" PRIu32, mode);
#ifndef DISABLE_AD9361
  this->log_info("noos ad9361_set_rx_rf_port_input m_ad9361_rf_phy %i %" PRIu32, m_ad9361_rf_phy, mode);
  int32_t res = ad9361_set_rx_rf_port_input(m_ad9361_rf_phy, mode);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_tx_rf_port_output(uint32_t mode) {
  init_if_required();
  this->log_info("noos ad9361_set_tx_rf_port_output %" PRIu32, mode);
#ifndef DISABLE_AD9361
  int32_t res = ad9361_set_tx_rf_port_output(m_ad9361_rf_phy, mode);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::throw_if_no_os_api_call_returns_non_zero(
    int32_t res) {
  init_if_required();
  if(res != 0) {
    throw std::string("No-OS API call returned non-zero value");
  }
}

/// @todo / FIXME - check for existence of qadc/qdac?
template<class cfgrtr_t> bool
AD9361DRC<cfgrtr_t>::get_enabled(const std::string& rf_port_name) {
  bool ret = true;
  get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
#ifndef DISABLE_AD9361
  if(not m_ad9361_init_called) {
    ret = false;
  }
  if(ret) {
    if(rf_port_name == m_port_rx1) {
      if(m_init_param.two_rx_two_tx_mode_enable) {
        ret = true;
      }
      else if(m_init_param.one_rx_one_tx_mode_use_rx_num == 1) {
        ret = true;
      }
    }
    else if(rf_port_name == m_port_rx2) {
      if(m_init_param.two_rx_two_tx_mode_enable) {
        ret = true;
      }
      else if(m_init_param.one_rx_one_tx_mode_use_rx_num == 2) {
        ret = true;
      }
    }
    else if(rf_port_name == m_port_tx1) {
      if(m_init_param.two_rx_two_tx_mode_enable) {
        ret = true;
      }
      else if(m_init_param.one_rx_one_tx_mode_use_tx_num == 1) {
        ret = true;
      }
    }
    else if(rf_port_name == m_port_tx2) {
      if(m_init_param.two_rx_two_tx_mode_enable) {
        ret = true;
      }
      else if(m_init_param.one_rx_one_tx_mode_use_tx_num == 2) {
        ret = true;
      }
    }
  }
#endif
  return ret;
}

template<class cfgrtr_t> uint64_t
AD9361DRC<cfgrtr_t>::get_noos_tuning_freq(const std::string& rf_port_name) {
  init_if_required();
  uint64_t ret = 0;
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  do_rx ?
      this->log_info("noos ad9361_get_rx_lo_freq") :
      this->log_info("noos ad9361_get_tx_lo_freq");
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS get tuning freq");
  int32_t res = do_rx ?
      ad9361_get_rx_lo_freq(m_ad9361_rf_phy, &ret) :
      ad9361_get_tx_lo_freq(m_ad9361_rf_phy, &ret);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
  return ret;
}

template<class cfgrtr_t> uint32_t
AD9361DRC<cfgrtr_t>::get_noos_bandwidth(const std::string& rf_port_name) {
  init_if_required();
  uint32_t ret = 0;
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  do_rx ?
      this->log_info("noos ad9361_get_rx_rf_bandwidth") :
      this->log_info("noos ad9361_get_tx_rf_bandwidth");
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS get bandwidth");
  int32_t res = do_rx ?
      ad9361_get_rx_rf_bandwidth(m_ad9361_rf_phy, &ret) :
      ad9361_get_tx_rf_bandwidth(m_ad9361_rf_phy, &ret);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
  return ret;
}

template<class cfgrtr_t> uint32_t
AD9361DRC<cfgrtr_t>::get_noos_sampling_rate(const std::string& rf_port_name) {
  init_if_required();
  uint32_t ret = 0;
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  do_rx ?
      this->log_info("noos ad9361_get_rx_sampling_freq") :
      this->log_info("noos ad9361_get_tx_sampling_freq");
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS get sampling rate");
  int32_t res = do_rx ?
      ad9361_get_rx_sampling_freq(m_ad9361_rf_phy, &ret) :
      ad9361_get_tx_sampling_freq(m_ad9361_rf_phy, &ret);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
  return ret;
}

template<class cfgrtr_t> uint8_t
AD9361DRC<cfgrtr_t>::get_noos_gain_mode(const std::string& rf_port_name) {
  init_if_required();
#ifdef DISABLE_AD9361
  uint8_t ret = 0;
#else
  uint8_t ret = RF_GAIN_MGC;// emulating tx channel manual only
#endif
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  if(do_rx) {
    this->log_info("noos ad9361_get_rx_gain_control_mode");
  }
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS get gain mode");
  if(do_rx) {
    uint8_t ch = get_ch(rf_port_name);
    int32_t res = ad9361_get_rx_gain_control_mode(m_ad9361_rf_phy, ch, &ret);
    throw_if_no_os_api_call_returns_non_zero(res);
  }
#endif
  return ret;
}

/// @return no-os returned rx gain value, in dB
template<class cfgrtr_t> int32_t
AD9361DRC<cfgrtr_t>::get_noos_rx_gain(const std::string& rf_port_name) {
  init_if_required();
  int32_t ret = 0;
  if((rf_port_name != m_port_rx1) && (rf_port_name != m_port_rx2)) { 
    throw std::string("invalid rx rf_port_name: ") + rf_port_name;
  }
  this->log_info("noos ad9361_get_rx_rf_gain");
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS get gain");
  uint8_t ch = get_ch(rf_port_name);
  int32_t res = ad9361_get_rx_rf_gain(m_ad9361_rf_phy, ch, &ret);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
  return ret;
}

/// @return no-os returned tx gain value, in millidB
template<class cfgrtr_t> uint32_t
AD9361DRC<cfgrtr_t>::get_noos_tx_gain(const std::string& rf_port_name) {
  init_if_required();
  uint32_t ret = 0;
  if((rf_port_name != m_port_tx1) && (rf_port_name != m_port_tx2)) { 
    throw std::string("invalid rx rf_port_name: ") + rf_port_name;
  }
  this->log_info("noos ad9361_get_tx_attenuation");
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS get gain");
  uint8_t ch = get_ch(rf_port_name);
  int32_t res = ad9361_get_tx_attenuation(m_ad9361_rf_phy, ch, &ret);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
  return ret;
}

template<class cfgrtr_t>
RFPort::direction_t 
AD9361DRC<cfgrtr_t>::get_direction(const std::string& rf_port_name) {
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  return do_rx ? RFPort::direction_t::rx : RFPort::direction_t::tx;
}

template<class cfgrtr_t> double 
AD9361DRC<cfgrtr_t>::get_tuning_freq_MHz(const std::string& rf_port_name) {
  return ((double)get_noos_tuning_freq(rf_port_name))/1000000.;
}

template<class cfgrtr_t> double 
AD9361DRC<cfgrtr_t>::get_bandwidth_3dB_MHz(const std::string& rf_port_name) {
  ///@TODO / FIXME handle DDC/DUC divider in separate DDC/DUC class
  double ret = (double)get_noos_bandwidth(rf_port_name);
  ret = ret/1000000./m_divider;
  return ret;
}

template<class cfgrtr_t> double 
AD9361DRC<cfgrtr_t>::get_sampling_rate_Msps(const std::string& rf_port_name) {
  ///@TODO / FIXME handle DDC/DUC divider in separate DDC/DUC class
  double ret = (double)get_noos_sampling_rate(rf_port_name);
  ret = ret/1000000./m_divider;
  return ret;
}

template<class cfgrtr_t> bool
AD9361DRC<cfgrtr_t>::get_samples_are_complex(const std::string& rf_port_name) {
  get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  return true;
}

template<class cfgrtr_t> std::string
AD9361DRC<cfgrtr_t>::get_gain_mode(const std::string& rf_port_name) {
  std::string ret = "manual";
#ifndef DISABLE_AD9361
  uint8_t val = get_noos_gain_mode(rf_port_name);
  if(val == RF_GAIN_MGC) {
    ret = "manual";
  }
  else if(val == RF_GAIN_FASTATTACK_AGC) {
    ret = "agc";
  }
  else if(val == RF_GAIN_SLOWATTACK_AGC) {
    ret = "agc";
  }
  else if(val == RF_GAIN_HYBRID_AGC) {
    ret = "agc";
  }
  else {
    throw std::string("invalid read ad9361_get_rx_gain_control_mode");
  }
#endif
  return ret;
}

template<class cfgrtr_t> double 
AD9361DRC<cfgrtr_t>::get_gain_dB(const std::string& rf_port) {
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port);
  if(do_rx) {
    return (double)get_noos_rx_gain(rf_port);
  }
  else {
    return (double)convert_milli_db_to_db(get_noos_tx_gain(rf_port));
  }
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_direction(const std::string& rf_port_name,
    RFPort::direction_t /*val*/) {
  get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_tuning_freq_MHz(const std::string& rf_port_name, double val) {
  init_if_required();
  uint64_t lo_freq_hz = std::round(val*1000000.);
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  do_rx ?
      this->log_info("noos ad9361_set_rx_lo_freq %" PRIu64, lo_freq_hz) :
      this->log_info("noos ad9361_set_tx_lo_freq %" PRIu64, lo_freq_hz);
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS set tuning freq");
  do_rx ?
      ad9361_set_rx_rf_port_input(m_ad9361_rf_phy,m_callback.getRfInput(m_device,val)) :
      ad9361_set_tx_rf_port_output(m_ad9361_rf_phy,m_callback.getRfOutput(m_device,val));
  int32_t res = do_rx ?
      ad9361_set_rx_lo_freq(m_ad9361_rf_phy, lo_freq_hz) :
      ad9361_set_tx_lo_freq(m_ad9361_rf_phy, lo_freq_hz);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_bandwidth_3dB_MHz(const std::string& rf_port_name,
    double val) {
  init_if_required();
  ///@TODO / FIXME handle DDC/DUC divider in separate DDC/DUC class
  uint32_t bw = (uint32_t)std::round(val*1000000.*m_divider);
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  do_rx ?
      this->log_info("noos ad9361_set_rx_rf_bandwidth %" PRIu32, bw) :
      this->log_info("noos ad9361_set_tx_rf_bandwidth %" PRIu32, bw);
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS set bandwidth");
  int32_t res = do_rx ?
      ad9361_set_rx_rf_bandwidth(m_ad9361_rf_phy, bw) :
      ad9361_set_tx_rf_bandwidth(m_ad9361_rf_phy, bw);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_sampling_rate_Msps(const std::string& rf_port_name,
    double val) {
  init_if_required();
  ///@TODO / FIXME handle DDC/DUC divider in separate DDC/DUC class
  uint32_t fs = (uint32_t)std::round(val*1000000.*m_divider);
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  do_rx ?
      this->log_info("noos ad9361_set_rx_sampling_freq %" PRIu32, fs) :
      this->log_info("noos ad9361_set_tx_sampling_freq %" PRIu32, fs);
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS set sampling freq");
  int32_t res = do_rx ?
      ad9361_set_rx_sampling_freq(m_ad9361_rf_phy, fs) :
      ad9361_set_tx_sampling_freq(m_ad9361_rf_phy, fs);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_samples_are_complex(const std::string& rf_port_name,
    bool val) {
  // nothing to do on hardware, just validate settings
  if(val == false) {
    throw std::string("samples_are_complex must be set to true");
  }
  get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_gain_mode(const std::string& rf_port_name, const std::string& val) {
  init_if_required();
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  if((!do_rx) && val != "manual") {
    throw std::string("not a valid setting for TX: ") + val.c_str();
  }
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS set gain mode");
  // assign No-OS-specific "channel" macro (RX1/RX2/TX1/TX2 in ad9361_api.h)
  uint8_t gc_mode = (val == "manual") ? RF_GAIN_MGC :
                    (val == "RF_GAIN_MGC") ? RF_GAIN_MGC :
                    (val == "auto") ? RF_GAIN_SLOWATTACK_AGC :
                    (val == "RF_GAIN_SLOWATTACK_AGC") ? RF_GAIN_SLOWATTACK_AGC :
                    (val == "RF_GAIN_FASTATTACK_AGC") ? RF_GAIN_FASTATTACK_AGC :
                    (val == "RF_GAIN_HYBRID_AGC ") ? RF_GAIN_HYBRID_AGC :
                    RF_GAIN_MGC;
  uint8_t ch = get_ch(rf_port_name);
  if(do_rx) {
    this->log_info("noos ad9361_set_rx_gain_control_mode %" PRIu8, gc_mode);
    int32_t res = do_rx ?
        ad9361_set_rx_gain_control_mode(m_ad9361_rf_phy, ch, gc_mode) : 0;
    throw_if_no_os_api_call_returns_non_zero(res);
  }
#endif
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_gain_dB(const std::string& rf_port_name, double val) {
  init_if_required();
  bool do_rx = get_rx_and_throw_if_invalid_rf_port_name(rf_port_name);
  // expected type of ad9361_set_rx_rf_gain
  int32_t rx_val = 0;
  // expected type of ad9361_set_tx_attenuation
  uint32_t tx_val = 0;
  if(do_rx) {
    rx_val = (int32_t)std::round(val);
  }
  else {
    tx_val = std::round(convert_db_to_milli_db(val));
  }
  do_rx ?
      this->log_info("noos ad9361_set_rx_rf_gain %" PRId32, rx_val) :
      this->log_info("noos ad9361_set_tx_attenuation %" PRIu32, tx_val);
#ifndef DISABLE_AD9361
  this->throw_if_ad9361_init_failed("No-OS set get");
  // assign No-OS-specific "channel" macro (RX1/RX2/TX1/TX2 in ad9361_api.h)
  uint8_t ch = get_ch(rf_port_name);
  int32_t res = do_rx ?
      ad9361_set_rx_rf_gain(m_ad9361_rf_phy, ch, rx_val) :
      ad9361_set_tx_attenuation(m_ad9361_rf_phy, ch, tx_val);
  throw_if_no_os_api_call_returns_non_zero(res);
#endif
}

template<class cfgrtr_t> uint8_t
AD9361DRC<cfgrtr_t>::get_app_port_num(const std::string& /*rf_port_name*/) {
  return 0;
}

template<class cfgrtr_t> void
AD9361DRC<cfgrtr_t>::set_app_port_num(const std::string& /*rf_port_name*/, uint8_t val) {
  if(val != 0) {
    throw std::string("current implementation cannot set non-zero app port num");
  }
}

///@TODO / FIXME - does this need to undo ENSM_MODE_ALERT??
//template<class cfgrtr_t> bool
//AD9361DRC<cfgrtr_t>::start(unsigned config) {
//}

  ///@TODO enable me!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
template<class cfgrtr_t> bool
AD9361DRC<cfgrtr_t>::stop(unsigned config) {
  bool ret = true;
#if 0
#ifndef DISABLE_AD9361
  // From AD9361 datasheet:
  // FDD is "TX and RX signal chains enabled", but Alert is only "synthesizers enabled"
  this->log_info("noos ad9361_set_en_state_machine_mode %i" ENSM_MODE_ALERT);
  ret = ad9361_set_en_state_machine_mode(m_ad9361_rf_phy, ENSM_MODE_ALERT);
#endif
#endif
  if(!DRC<cfgrtr_t>::stop(config)) {
    ret = false;
  }
  return ret;
}

template<class cfgrtr_t>
AD9361DRC<cfgrtr_t>::~AD9361DRC() {
#ifndef DISABLE_AD9361
  // only free internally managed No-OS memory
  ad9361_free(m_ad9361_rf_phy); // this function added in ad9361.patch
#endif
}

} // namespace DRC_PHASE_2

} // namespace OCPI
