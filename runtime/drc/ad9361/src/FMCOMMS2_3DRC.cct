/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of OpenCPI <http://www.opencpi.org>
 *
 * OpenCPI is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "FMCOMMS2_3DRC.hh"

namespace OCPI {

/// @todo / FIXME - consolidate into DRC namespace
namespace DRC_PHASE_2 {

// -----------------------------------------------------------------------------
// STEP 1 - DEFINE Constraint Satisfaction Problem (CSP)
// -----------------------------------------------------------------------------

/* @brief for the FMCOMMS2_3,
 *        define variables (X) and their domains (D) for <X,D,C> which
 *        comprises its Constraint Satisfaction Problem (CSP)
 ******************************************************************************/
void
FMCOMMS2_3CSP::define_x_d_fmcomms2_3() {
  // N/A
  m_solver.add_var<int32_t>("fmcomms_num");
  m_solver.add_var<double>("fmcomms2_fc_baluns_meghz", dfp_tol);
  // direction
  m_solver.add_var<int32_t>("fmcomms2_3_dir_rx1a");
  m_solver.add_var<int32_t>("fmcomms2_3_dir_rx2a");
  m_solver.add_var<int32_t>("fmcomms2_3_dir_tx1a");
  m_solver.add_var<int32_t>("fmcomms2_3_dir_tx2a");
  // tuning_freq_MHz
  m_solver.add_var<double>("fmcomms2_3_fc_meghz_rx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_fc_meghz_rx2a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_fc_meghz_tx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_fc_meghz_tx2a", dfp_tol);
  // bandwidth_3dB_MHz
  m_solver.add_var<double>("fmcomms2_3_bw_meghz_rx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_bw_meghz_rx2a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_bw_meghz_tx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_bw_meghz_tx2a", dfp_tol);
  // sampling_rate_Msps
  m_solver.add_var<double>("fmcomms2_3_fs_megsps_rx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_fs_megsps_rx2a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_fs_megsps_tx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_fs_megsps_tx2a", dfp_tol);
  // samples_are_complex
  m_solver.add_var<int32_t>("fmcomms2_3_samps_comp_rx1a");
  m_solver.add_var<int32_t>("fmcomms2_3_samps_comp_rx2a");
  m_solver.add_var<int32_t>("fmcomms2_3_samps_comp_tx1a");
  m_solver.add_var<int32_t>("fmcomms2_3_samps_comp_tx2a");
  // gain_mode
  m_solver.add_var<int32_t>("fmcomms2_3_gain_mode_rx1a");
  m_solver.add_var<int32_t>("fmcomms2_3_gain_mode_rx2a");
  m_solver.add_var<int32_t>("fmcomms2_3_gain_mode_tx1a");
  m_solver.add_var<int32_t>("fmcomms2_3_gain_mode_tx2a");
  // gain_dB
  m_solver.add_var<double>("fmcomms2_3_gain_db_rx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_gain_db_rx2a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_gain_db_tx1a", dfp_tol);
  m_solver.add_var<double>("fmcomms2_3_gain_db_tx2a", dfp_tol);
}

/* @brief for the FMCOMMS2_3,
 *        define constraints (C) for <X,D,C> which
 *        comprise its Constraint Satisfaction Problem (CSP)
 ******************************************************************************/
void
FMCOMMS2_3CSP::define_c_fmcomms2_3() {
  // N/A
  m_solver.add_constr("fmcomms_num", ">=", (int32_t)2);
  m_solver.add_constr("fmcomms_num", "<=", (int32_t)3);
  m_solver.add_constr("fmcomms2_fc_baluns_meghz", ">=", 2400.);
  m_solver.add_constr("fmcomms2_fc_baluns_meghz", "<=", 2500.);
  // direction
  m_solver.add_constr("fmcomms2_3_dir_rx1a", "=", "ad9361_dir_rx1");
  m_solver.add_constr("fmcomms2_3_dir_rx2a", "=", "ad9361_dir_rx2");
  m_solver.add_constr("fmcomms2_3_dir_tx1a", "=", "ad9361_dir_tx1");
  m_solver.add_constr("fmcomms2_3_dir_tx2a", "=", "ad9361_dir_tx2");
  // tuning_freq_MHz (fmcomms2)
  //  @TODO add 'intersected with' functionality
  m_solver.add_constr("fmcomms2_3_fc_meghz_rx1a", "=", "ad9361_fc_meghz_rx1");//, intersected with fmcomms2_fc_baluns_meghz
  m_solver.add_constr("fmcomms2_3_fc_meghz_rx2a", "=", "ad9361_fc_meghz_rx2");//, intersected with fmcomms2_fc_baluns_meghz
  m_solver.add_constr("fmcomms2_3_fc_meghz_tx1a", "=", "ad9361_fc_meghz_tx1");//, intersected with fmcomms2_fc_baluns_meghz
  m_solver.add_constr("fmcomms2_3_fc_meghz_tx2a", "=", "ad9361_fc_meghz_tx2");//, intersected with fmcomms2_fc_baluns_meghz
  // tuning_freq_MHz (fmcomms3)
  m_solver.add_constr("fmcomms2_3_fc_meghz_rx1a", "=", "ad9361_fc_meghz_rx1");
  m_solver.add_constr("fmcomms2_3_fc_meghz_rx2a", "=", "ad9361_fc_meghz_rx2");
  m_solver.add_constr("fmcomms2_3_fc_meghz_tx1a", "=", "ad9361_fc_meghz_tx1");
  m_solver.add_constr("fmcomms2_3_fc_meghz_tx2a", "=", "ad9361_fc_meghz_tx2");
  // bandwidth_3dB_MHz
  m_solver.add_constr("fmcomms2_3_bw_meghz_rx1a", "=", "ad9361_bw_meghz_rx1");
  m_solver.add_constr("fmcomms2_3_bw_meghz_rx2a", "=", "ad9361_bw_meghz_rx2");
  m_solver.add_constr("fmcomms2_3_bw_meghz_tx1a", "=", "ad9361_bw_meghz_tx1");
  m_solver.add_constr("fmcomms2_3_bw_meghz_tx2a", "=", "ad9361_bw_meghz_tx2");
  // sampling_rate_Msps
  m_solver.add_constr("fmcomms2_3_fs_megsps_rx1a", "=", "ad9361_fs_megsps_rx1");
  m_solver.add_constr("fmcomms2_3_fs_megsps_rx2a", "=", "ad9361_fs_megsps_rx2");
  m_solver.add_constr("fmcomms2_3_fs_megsps_tx1a", "=", "ad9361_fs_megsps_tx1");
  m_solver.add_constr("fmcomms2_3_fs_megsps_tx2a", "=", "ad9361_fs_megsps_tx2");
  // samples_are_complex
  m_solver.add_constr("fmcomms2_3_samps_comp_rx1a", "=", "ad9361_samps_comp_rx1");
  m_solver.add_constr("fmcomms2_3_samps_comp_rx2a", "=", "ad9361_samps_comp_rx2");
  m_solver.add_constr("fmcomms2_3_samps_comp_tx1a", "=", "ad9361_samps_comp_tx1");
  m_solver.add_constr("fmcomms2_3_samps_comp_tx2a", "=", "ad9361_samps_comp_tx2");
  // gain_mode
  m_solver.add_constr("fmcomms2_3_gain_mode_rx1a", "=", "ad9361_gain_mode_rx1");
  m_solver.add_constr("fmcomms2_3_gain_mode_rx2a", "=", "ad9361_gain_mode_rx2");
  m_solver.add_constr("fmcomms2_3_gain_mode_tx1a", "=", "ad9361_gain_mode_tx1");
  m_solver.add_constr("fmcomms2_3_gain_mode_tx2a", "=", "ad9361_gain_mode_tx2");
  // gain_dB
  m_solver.add_constr("fmcomms2_3_gain_db_rx1a", "=", "ad9361_gain_db_rx1");
  m_solver.add_constr("fmcomms2_3_gain_db_rx2a", "=", "ad9361_gain_db_rx2");
  m_solver.add_constr("fmcomms2_3_gain_db_tx1a", "=", "ad9361_gain_db_tx1");
  m_solver.add_constr("fmcomms2_3_gain_db_tx2a", "=", "ad9361_gain_db_tx2");
}

FMCOMMS2_3CSP::FMCOMMS2_3CSP() : AD9361CSP() {
  define();
  //std::cout << "[INFO] " << get_feasible_region_limits() << "\n";
}

void
FMCOMMS2_3CSP::connect_fmcomms2_3_to_ad9361() {
  define_c_fmcomms2_3();
}

/* @brief instance FMCOMMS2/3
 *        by defining its Constraint Satisfaction Problem (CSP) as <X,D,C>
 ******************************************************************************/
void
FMCOMMS2_3CSP::instance_fmcomms2_3() {
  instance_ad9361();
  std::cout << "define";
  define_x_d_fmcomms2_3();
  std::cout << "define";
  connect_fmcomms2_3_to_ad9361();
}

/// @brief define Constraint Satisfaction Problem (CSP)
void
FMCOMMS2_3CSP::define() {
  instance_fmcomms2_3();
}

// -----------------------------------------------------------------------------
// STEP 2 - DEFINE CONFIGURATOR THAT UTILIZES THE CSP
// -----------------------------------------------------------------------------

void
FMCOMMS2_3Configurator::init_rf_port_rx1a() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names (a CSP is generic and knows nothing about a DRC, this is
  // what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "fmcomms2_3_dir_rx1a"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "fmcomms2_3_fc_meghz_rx1a"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "fmcomms2_3_bw_meghz_rx1a"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "fmcomms2_3_fs_megsps_rx1a"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "fmcomms2_3_samps_comp_rx1a"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "fmcomms2_3_gain_mode_rx1a"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "fmcomms2_3_gain_db_rx1a"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  ///@TODO / FIXME hardcoded mapping in below line
  m_dict["Rx0"/*"rx1a"*/] = map;
}

void
FMCOMMS2_3Configurator::init_rf_port_rx2a() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names (a CSP is generic and knows nothing about a DRC, this is
  // what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "fmcomms2_3_dir_rx2a"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "fmcomms2_3_fc_meghz_rx2a"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "fmcomms2_3_bw_meghz_rx2a"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "fmcomms2_3_fs_megsps_rx2a"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "fmcomms2_3_samps_comp_rx2a"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "fmcomms2_3_gain_mode_rx2a"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "fmcomms2_3_gain_db_rx2a"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  ///@TODO / FIXME hardcoded mapping in below line
  m_dict["Rx1"/*"rx2a"*/] = map;
}

void
FMCOMMS2_3Configurator::init_rf_port_tx1a() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names (a CSP is generic and knows nothing about a DRC, this is
  // what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "fmcomms2_3_dir_tx1a"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "fmcomms2_3_fc_meghz_tx1a"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "fmcomms2_3_bw_meghz_tx1a"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "fmcomms2_3_fs_megsps_tx1a"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "fmcomms2_3_samps_comp_tx1a"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "fmcomms2_3_gain_mode_tx1a"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "fmcomms2_3_gain_db_tx1a"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  ///@TODO / FIXME hardcoded mapping in below line
  m_dict["Tx0"/*"tx1a"*/] = map;
}

void
FMCOMMS2_3Configurator::init_rf_port_tx2a() {
  // maps each of the DRC-specific RFPort::config_t types to their corresponding CSP
  // variables names (a CSP is generic and knows nothing about a DRC, this is
  // what ties the two together)
  CSPVarMap map;
  map.insert(std::make_pair(RFPort::config_t::direction,
      "fmcomms2_3_dir_tx2a"));
  map.insert(std::make_pair(RFPort::config_t::tuning_freq_MHz,
      "fmcomms2_3_fc_meghz_tx2a"));
  map.insert(std::make_pair(RFPort::config_t::bandwidth_3dB_MHz,
      "fmcomms2_3_bw_meghz_tx2a"));
  map.insert(std::make_pair(RFPort::config_t::sampling_rate_Msps,
      "fmcomms2_3_fs_megsps_tx2a"));
  map.insert(std::make_pair(RFPort::config_t::samples_are_complex,
      "fmcomms2_3_samps_comp_tx2a"));
  map.insert(std::make_pair(RFPort::config_t::gain_mode,
      "fmcomms2_3_gain_mode_tx2a"));
  map.insert(std::make_pair(RFPort::config_t::gain_dB,
      "fmcomms2_3_gain_db_tx2a"));
  // make a dictionary entry which ties the mapping to a particular rf_port_name
  ///@TODO / FIXME hardcoded mapping in below line
  m_dict["Tx1"/*"tx2a"*/] = map;
}

///@TODO / FIXME - add fmcomms_num
FMCOMMS2_3Configurator::FMCOMMS2_3Configurator(int32_t /*fmcomms_num*/) :
    Configurator<FMCOMMS2_3CSP>() {
  //m_solver.add_constr("fmcomms_num", "=", (int32_t)fmcomms_num);
  init_rf_port_rx1a();
  init_rf_port_rx2a();
  init_rf_port_tx1a();
  init_rf_port_tx2a();
}

// -----------------------------------------------------------------------------
// STEP 3 - DEFINE DRC (get/set APIs)
// -----------------------------------------------------------------------------

///@TODO / FIXME - add fmcomms_num
template<class cfgrtr_t>
FMCOMMS2_3DRC<cfgrtr_t>::FMCOMMS2_3DRC(unsigned which,
		AD9361DeviceCallBack &dev, double fref_hz, int32_t /*fmcomms_num*/,
    const char* rx1a, const char* rx2a, const char* tx1a, const char* tx2a,
    const char* descriptor) :
    AD9361DRC<cfgrtr_t>(which,dev,fref_hz,rx1a,rx2a,tx1a,tx2a,descriptor),
    m_port_rx1a(rx1a), m_port_rx2a(rx2a), m_port_tx1a(tx1a), m_port_tx2a(tx2a) {
}

template<class cfgrtr_t> const std::string&
FMCOMMS2_3DRC<cfgrtr_t>::get_ad9361_rf_port_name(const std::string& rf_port_name) const {
  /// @TODO / FIXME figure out why this is commented out
  //return rf_port_name==m_port_rx1a ? "rx1" :  rf_port_name==m_port_rx1a ? "rx2" : rf_port_name==m_port_rx1a ? "tx1" :
  //    rf_port_name==m_port_rx1a ? "tx2" : "rx1"; 
  return rf_port_name;
}

template<class cfgrtr_t> bool
FMCOMMS2_3DRC<cfgrtr_t>::get_enabled(const std::string& rf_port_name) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::get_enabled(port);
}

template<class cfgrtr_t> RFPort::direction_t 
FMCOMMS2_3DRC<cfgrtr_t>::get_direction(const std::string& rf_port_name) {
  RFPort::direction_t ret = RFPort::direction_t::tx;
  if((rf_port_name==m_port_rx1a) || (rf_port_name==m_port_rx2a)) {
    ret = RFPort::direction_t::rx;
  }
  return ret;
}

template<class cfgrtr_t> double 
FMCOMMS2_3DRC<cfgrtr_t>::get_tuning_freq_MHz(const std::string& rf_port_name) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::get_tuning_freq_MHz(port);
}

template<class cfgrtr_t> double 
FMCOMMS2_3DRC<cfgrtr_t>::get_bandwidth_3dB_MHz(const std::string& rf_port_name) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::get_bandwidth_3dB_MHz(port);
}

template<class cfgrtr_t> double 
FMCOMMS2_3DRC<cfgrtr_t>::get_sampling_rate_Msps(const std::string& rf_port_name) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::get_sampling_rate_Msps(port);
}

template<class cfgrtr_t> bool
FMCOMMS2_3DRC<cfgrtr_t>::get_samples_are_complex(const std::string& rf_port_name) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::get_samples_are_complex(port);
}

template<class cfgrtr_t> std::string
FMCOMMS2_3DRC<cfgrtr_t>::get_gain_mode(const std::string& rf_port) {
  return AD9361DRC<cfgrtr_t>::get_gain_mode(get_ad9361_rf_port_name(rf_port));
}

template<class cfgrtr_t> double 
FMCOMMS2_3DRC<cfgrtr_t>::get_gain_dB(const std::string& rf_port) {
  return AD9361DRC<cfgrtr_t>::get_gain_dB(get_ad9361_rf_port_name(rf_port));
}

template<class cfgrtr_t> uint8_t 
FMCOMMS2_3DRC<cfgrtr_t>::get_app_port_num(const std::string& rf_port) {
  return AD9361DRC<cfgrtr_t>::get_app_port_num(get_ad9361_rf_port_name(rf_port));
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_direction(const std::string& rf_port_name,
    RFPort::direction_t val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_direction(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_tuning_freq_MHz(const std::string& rf_port_name,
    double val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_tuning_freq_MHz(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_bandwidth_3dB_MHz(const std::string& rf_port_name,
    double val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_bandwidth_3dB_MHz(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_sampling_rate_Msps(const std::string& rf_port_name,
    double val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_sampling_rate_Msps(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_samples_are_complex(const std::string& rf_port_name,
    bool val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_samples_are_complex(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_gain_mode(const std::string& rf_port_name,
    const std::string& val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_gain_mode(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_gain_dB(const std::string& rf_port_name, double val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_gain_dB(port, val);
}

template<class cfgrtr_t> void
FMCOMMS2_3DRC<cfgrtr_t>::set_app_port_num(const std::string& rf_port_name,
    uint8_t val) {
  auto port = get_ad9361_rf_port_name(rf_port_name);
  return AD9361DRC<cfgrtr_t>::set_app_port_num(port, val);
}

template<class cfgrtr_t> bool
FMCOMMS2_3DRC<cfgrtr_t>::shutdown() {
  return AD9361DRC<cfgrtr_t>::shutdown();
}

} // namespace DRC_PHASE_2

} // namespace OCPI
